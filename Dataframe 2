# Packages
import pandas as pd
import numpy as np
from tableauscraper import TableauScraper as TS
from dash import Dash, html, Input, Output, dash_table
import plotly.express as px
import plotly.io as pio
import plotly.graph_objects as go
import sklearn as sk
import sklearn.linear_model
import random

# Only 2021 for data
url = "https://visualizedata.ucop.edu/t/Public/views/AdmissionsDataTable/TREthbyYr?:embed_code_version=3&:embed=y&:loadOrderID=0&:display_spinner=no&:showAppBanner=false&:display_count=n&:showVizHome=n&:origin=viz_share_link"
ts = TS()
ts.loads(url)
workbook = ts.getWorkbook()
app_frame.sort_values('Value', ascending=False).drop_duplicates('School').sort_index()

for t in workbook.worksheets:
    print(f"worksheet name : {t.name}") #show worksheet name
    print(t.data) #show dataframe for this worksheet
   
mainframe = t.data
mainframe.drop(mainframe.columns[[1, 2, 3, 4, 7, 8, 11]], axis=1, inplace=True)
mainframe.rename(columns = {'School-value': 'School', 'County-alias': 'County', 'City-value': 'City', 'Count-alias': 'Type', 'Uad Uc Ethn 6 Cat-value': 'Eth','SUM(Pivot Field Values)-alias':'Value'}, inplace = True)
mainframe.loc[mainframe["Value"] == "%null%", "Value"] = 0

# We may want to get rid of the 'Unknown' ethnicity
enr_frame = mainframe.loc[(mainframe['Type'] == 'Enr') & (mainframe['Eth'] != 'All')] # This is cuz everytime you sort for what eth has the most, 'All' will return every time.
adm_frame = mainframe.loc[(mainframe['Type'] == 'Adm') & (mainframe['Eth'] != 'All')]
app_frame = mainframe.loc[(mainframe['Type'] == 'App') & (mainframe['Eth'] != 'All')]
tot_frame = mainframe[mainframe['Eth'] == 'All']

# Resetting index so we can properly divide the columns later
enr_frame = enr_frame.reset_index()
adm_frame = adm_frame.reset_index()
app_frame = app_frame.reset_index()

# Getting rid of index col
enr_frame.drop(enr_frame.columns[[0]],axis=1,inplace=True) 
adm_frame.drop(adm_frame.columns[[0]], axis = 1, inplace = True)
app_frame.drop(app_frame.columns[[0]],axis=1,inplace=True)

# Switching to float for division later ,see line 50
app_frame['Value'] = pd.to_numeric(app_frame['Value'])
adm_frame['Value'] = pd.to_numeric(adm_frame['Value'])
enr_frame['Value'] = pd.to_numeric(adm_frame['Value'])

int_enr = mainframe.loc[(mainframe['Type'] == 'Enr') & (mainframe['Eth'] == 'International')] # For both enroll and international students
int_enr.sort_values(by=['Value'], ascending = False)
tot_frame[tot_frame.Type == 'App'].sort_values(by=['Value'], ascending = False) # Which colleges generally get the most students admitted

enr_frame.sort_values(by=['Value'], ascending = False) # I want to create a ratio for these so that we can see what schools have the best admit rates, or most of what ethnicity.

# Right now, we can produce a lot of descriptive statistics. We need to produce ratios of different ethnicities for each college.
# For example, using ALLAN HANCOCK COLLEGE value for 'All', I want to divide each individual ethnicity by this value. 

# This gives us a rate. The rate is the percentage of students that were admitted out of those who applied for each eth at each school.
# The idea is that we could see which ethnicity had the highest rate and use that for our stats. 

# Rate Column
pd.set_option('mode.use_inf_as_na', True)
app_frame['Value'] = pd.to_numeric(app_frame['Value'])
adm_frame['Value'] = pd.to_numeric(adm_frame['Value'])
adm_frame['Rate'] = adm_frame['Value']/app_frame['Value']
adm_frame = adm_frame.fillna(0)

# Adm Max Frame
adm _max = adm_frame.sort_values('Value', ascending=False).drop_duplicates('School').sort_index() # For each school, it returns the ethnicity group who got the most admits. 
adm_max[adm_max.School == 'DIABLO VALLEY COLLEGE'] # Just one instance for a school
adm_max.Eth.value_counts() # This is the count of what ethnicity each college's max amount of admits is equal to.

# Both below were just to see what it looked like 
adm_frame[adm_frame.Eth == 'American Indian'].sort_values(by = ['Rate'], ascending = False).head(20)
adm_frame.sort_values('Rate', ascending=False).head(10)

adm_frame.loc[adm_frame['Rate'] == 1.0] # Colleges with admit rate of 100% per ethnicity
adm_frame.loc[adm_frame['Rate'] == 1.0]['Eth'].value_counts() # Counts how many time each eth appears for those that had 100% admit rate. Good for desc stats.

# To check whether or not the international count were outliers. 
one_outs = adm_frame.loc[adm_frame['Rate'] == 1.0]
inters = one_outs[one_outs['Eth'] == 'International']['School'] # The 11 schools with 100% international student admittance
result1 = adm_max[adm_max['School'].isin(list(inters))]
result1 # From this result, we see that all the schools with a 100% international student admit rate, do not have international students as their ethnicity with max admittance.  


## Plots

# Interactive Boxplot
fig = px.box(adm_frame, x="Rate", y="Eth", color="Eth", points = "all",
                 labels={
                     "Rate": "Admittance Rate",
                     "Eth": "Ethnicity",
                 },
                title="Boxplot of Admittance Rate Per Each Ethnicity")
fig.show()

# For scatterplot regression one, I scrapped it tho.
def label_race(row):
   if row['Eth'] == 'International':
      return random.randint(1,10)
   if row['Eth'] == 'Unknown':
      return random.randint(11,20)
   if row['Eth'] == 'White':
      return random.randint(21, 30)
   if row['Eth'] == 'Asian':
      return random.randint(31, 40)
   if row['Eth']  == 'Chicano/Latino':
      return random.randint(41,50)
   if row['Eth'] == 'American Indian':
      return random.randint(51,60)
   if row['Eth'] == 'African American':
      return random.randint(61,70)

adm_frame['Race Label'] = adm_frame.apply(lambda row: label_race(row), axis=1)
test_frame = adm_frame.loc[adm_frame['Rate']>0]

# Gives an OLS line for each Ethnicity. It's all right
fig = px.scatter(adm_frame, 
                 x = 'Value',
                 y = 'Rate',
                 template = 'plotly_dark',
                 color = 'Eth',
                 trendline = 'ols',
                 title = 'Admit Rate Per Different Ethnicities')
fig.update_layout(showlegend=True)
fig.show()

# Interactive Table for the admit max frame
fig = go.Figure(data=[go.Table(
    header=dict(values=list(adm_max.columns),
                fill_color='lavenderblush',
                align='left'),
    cells=dict(values=[adm_max.School, adm_max.County, adm_max.City, adm_max.Type, adm_max.Eth, adm_max.Value, adm_max.Rate],
               fill_color='lavender',
               align='left'))
])
fig.update_layout(
    title_text = "Each CC's Most Admitted Ethnicity",
    title_font_size=30,
    font_family="Times New Roman",
    font_color="black",
    title_font_family="Times New Roman",
    title_font_color="black",
)
fig.update_traces(cells_font=dict(size = 10))
fig.show()

## Logistic Regression
from sklearn.linear_model import LogisticRegression

lr = LogisticRegression()
lr.fit(train[['Rate']], train['Eth'])
test.copy()
test['predicted'] = lr.predict(test[['Rate']])
lr.coef_, lr.intercept_
coef = np.vstack((lr.coef_.T, lr.intercept_))
coef
scores = test.iloc[:, 5:7] @ coef[:, :7]
scores = scores.set_axis([c+"-score" for c in lr.classes_],axis = 1)
log_frame = pd.concat((test,scores), axis = 1)
log_frame.head(5)

# 4 equation
lr = sk.linear_model.LogisticRegression()
fitted = lr.fit(adm_frame.Rate.values.reshape(-1, 1), adm_frame.Eth)
print(fitted.coef_)
print(fitted.intercept_)

# This is using the rates as the continuous variable and the ethnicity as the vars. Each coeff represents each ethnicity.
